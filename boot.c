/*
 * uefi-md5sum: UEFI MD5Sum validator
 * Copyright © 2023 Pete Batard <pete@akeo.ie>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "boot.h"

/* The following header is generated by the build process on prod */
#include "version.h"

/*
 * When performing tests with GitHub Actions, we want to remove all
 * colour formatting as well force shutdown on exit (to exit qemu)
 * so we need a variable to tell us if we are running in test mode.
 */
BOOLEAN IsTestMode = FALSE;

/* We'll use this string to erase a full line on the console */
CHAR16* EmptyLine = NULL;

/* Strings used to identify the plaform */
#if defined(_M_X64) || defined(__x86_64__)
  STATIC CHAR16* Arch = L"x64";
#elif defined(_M_IX86) || defined(__i386__)
  STATIC CHAR16* Arch = L"ia32";
#elif defined (_M_ARM64) || defined(__aarch64__)
  STATIC CHAR16* Arch = L"aa64";
#elif defined (_M_ARM) || defined(__arm__)
  STATIC CHAR16* Arch = L"arm";
#elif defined(_M_RISCV64) || (defined (__riscv) && (__riscv_xlen == 64))
  STATIC CHAR16* Arch = L"riscv64";
#else
#  error Unsupported architecture
#endif

/**
  Display a centered application banner
 **/
STATIC VOID DisplayBanner(
	IN UINTN Cols
)
{
	UINTN i, Len;
	CHAR16* Line;

	// Don't display the banner in test mode
	if (IsTestMode)
		return;

	// The platform logo may still be displayed → remove it
	gST->ConOut->ClearScreen(gST->ConOut);

	V_ASSERT(Cols > 79);
	Line = AllocatePool((Cols + 1) * sizeof(CHAR16));
	if (Line == NULL)
		return;

	Cols -= 1;
	SetTextPosition(0, 0);
	SetText(TEXT_REVERSED);
	Print(L"%c", BOXDRAW_DOWN_RIGHT);
	for (i = 0; i < Cols - 2; i++)
		Print(L"%c", BOXDRAW_HORIZONTAL);
	Print(L"%c", BOXDRAW_DOWN_LEFT);

	SetTextPosition(0, 1);
	UnicodeSPrint(Line, Cols, L"UEFI md5sum %s (%s)", VERSION_STRING, Arch);
	Len = SafeStrLen(Line);
	V_ASSERT(Len < Cols);
	Print(L"%c", BOXDRAW_VERTICAL);
	for (i = 1; i < (Cols - Len) / 2; i++)
		Print(L" ");
	Print(Line);
	for (i += Len; i < Cols - 1; i++)
		Print(L" ");
	Print(L"%c", BOXDRAW_VERTICAL);

	SetTextPosition(0, 2);
	UnicodeSPrint(Line, Cols, L"<https://md5.akeo.ie>");
	Len = SafeStrLen(Line);
	V_ASSERT(Len < Cols);
	Print(L"%c", BOXDRAW_VERTICAL);
	for (i = 1; i < (Cols - Len) / 2; i++)
		Print(L" ");
	Print(Line);
	for (i += Len; i < Cols - 1; i++)
		Print(L" ");
	Print(L"%c", BOXDRAW_VERTICAL);

	SetTextPosition(0, 3);
	Print(L"%c", BOXDRAW_UP_RIGHT);
	for (i = 0; i < Cols - 2; i++)
		Print(L"%c", BOXDRAW_HORIZONTAL);
	Print(L"%c", BOXDRAW_UP_LEFT);
	DefText();

	FreePool(Line);
}

/**
  Print a hash entry that has failed processing.
  Do this over a specific section of the console we cycle over.

  @param[in]  Status     The Status code from the failed operation on the entry.
  @param[in]  Path       A pointer to the CHAR16 string with the Path of the entry.
  @param[in]  NumFailed  The current number of failed entries.

**/
STATIC VOID PrintFailedEntry(
	IN CONST EFI_STATUS Status,
	IN CHAR16* Path,
	IN CONST UINTN NumFailed
)
{
	// Truncate the path in case it's very long.
	// TODO: Ideally we'd want long path reduction similar to what Windows does.
	if (SafeStrLen(Path) > 80)
		Path[80] = L'\0';
	SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 4 +
		(NumFailed % FAILED_ENTRIES_MAX));
	if (EmptyLine != NULL && !IsTestMode)
		Print(EmptyLine);
	SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 4 +
		(NumFailed % FAILED_ENTRIES_MAX));
	PrintError(L"File '%s'", Path);
}

/**
  Exit-specific processing for test/debug

  @param[in]  NumFailed  The total number of failed entries.
**/
STATIC VOID ExitCheck(
	IN INTN NumFailed
)
{
#if defined(EFI_DEBUG)
	UINTN Index;
#endif

	// If running in test mode, shut down QEMU
	if (IsTestMode)
		ShutDown();

	// If running debug, wait for a user keystroke and shut down
#if defined(EFI_DEBUG)
	SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 5 +
		MIN(NumFailed, FAILED_ENTRIES_MAX));
	SetText(TEXT_YELLOW);
	Print(L"Press any key to exit.\n");
	DefText();
	gST->ConIn->Reset(gST->ConIn, FALSE);
	gST->BootServices->WaitForEvent(1, &gST->ConIn->WaitForKey, &Index);
	ShutDown();
#endif
}

/*
 * Application entry-point
 * NB: This must be set to 'efi_main' for gnu-efi crt0 compatibility
 */
EFI_STATUS EFIAPI efi_main(
	IN EFI_HANDLE BaseImageHandle,
	IN EFI_SYSTEM_TABLE *SystemTable
)
{
	EFI_STATUS Status;
	EFI_LOADED_IMAGE_PROTOCOL* LoadedImage;
	EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* Volume;
	EFI_FILE_HANDLE Root;
	EFI_INPUT_KEY Key;
	HASH_LIST HashList = { 0 };
	CHAR8 c;
	CHAR16 Path[PATH_MAX + 1], NumFailedString[32] = { 0 }, *PluralFiles;
	UINT8 ComputedHash[MD5_HASHSIZE], ExpectedHash[MD5_HASHSIZE];
	UINTN i, Index, Cols, Rows, NumFailed = 0;

#if defined(_GNU_EFI)
	InitializeLib(BaseImageHandle, SystemTable);
#endif

	// Determine if we are running in test mode.
	// Note that test mode is no less secure than regular mode.
	// It only produces or removes extra onscreen output.
	IsTestMode = IsTestSystem();

	// Find the amount of console real-estate we have at out disposal
	Status = gST->ConOut->QueryMode(gST->ConOut, gST->ConOut->Mode->Mode,
		&Cols, &Rows);
	if (EFI_ERROR(Status)) {
		// Couldn't get the console dimensions
		Cols = 80;
		Rows = 40;
	}

	// Display the top banner
	DisplayBanner(Cols);

	// Create the blank line we'll use to erase a line
	EmptyLine = AllocateZeroPool((Cols + 1) * sizeof(CHAR16));
	if (EmptyLine != NULL) {
		for (i = 0; i < Cols; i++)
			EmptyLine[i] = L' ';
	}

	// Access the loaded image so we can open the current volume
	Status = gBS->OpenProtocol(BaseImageHandle, &gEfiLoadedImageProtocolGuid,
		(VOID**)&LoadedImage, BaseImageHandle,
		NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);
	if (EFI_ERROR(Status)) {
		PrintError(L"Unable to access boot image interface");
		goto out;
	}

	// Open the the root directory on the boot volume
	Status = gBS->OpenProtocol(LoadedImage->DeviceHandle,
		&gEfiSimpleFileSystemProtocolGuid, (VOID**)&Volume,
		BaseImageHandle, NULL, EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);
	if (EFI_ERROR(Status)) {
		PrintError(L"Unable to open boot volume");
		goto out;
	}
	Root = NULL;
	Status = Volume->OpenVolume(Volume, &Root);
	if (EFI_ERROR(Status)) {
		PrintError(L"Unable to open root directory");
		goto out;
	}

	// Parse md5sum.txt to construct a hash list
	Status = Parse(Root, HASH_FILE, &HashList);
	if (EFI_ERROR(Status))
		goto out;

	if (IsTestMode) {
		// Print any extra data we want to validate
		Print(L"[TEST] TotalBytes = 0x%lX\n", HashList.TotalBytes);
	} else {
		// Position our output near the center of the screen
		SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y);
		Print(L"Media verification - Press any key to cancel\n");
		// Clear the input buffer
		gST->ConIn->Reset(gST->ConIn, FALSE);
	}

	// Now go through each entry we parsed
	PluralFiles = (HashList.Size == 1) ? L"" : L"s";
	for (Index = 0; Index < HashList.Size; Index++) {
		// Check for user cancellation
		if (gST->ConIn->ReadKeyStroke(gST->ConIn, &Key) != EFI_NOT_READY)
			break;

		// Report progress
		if (!IsTestMode) {
			SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 2);
			Print(L"%d/%d file%s processed%s\n", Index,
				HashList.Size, PluralFiles, NumFailedString);
		}

		// Convert the expected hexascii hash to a binary value we can use
		ZeroMem(ExpectedHash, sizeof(ExpectedHash));
		for (i = 0; i < MD5_HASHSIZE * 2; i++) {
			c = HashList.Entry[Index].Hash[i];
			// The Parse() call should have filtered any invalid string
			V_ASSERT(IsValidHexAscii(c));
			ExpectedHash[i / 2] <<= 4;
			ExpectedHash[i / 2] |= c >= 'a' ? (c - 'a' + 0x0A) : c - '0';
		}

		// Convert the UTF-8 path to UCS-2
		Status = Utf8ToUcs2(HashList.Entry[Index].Path, Path, ARRAY_SIZE(Path));
		if (EFI_ERROR(Status)) {
			// Conversion failed but we want a UCS-2 Path for the failure
			// report so just filter out anything that is non lower ASCII.
			V_ASSERT(AsciiStrLen(HashList.Entry[Index].Path) < ARRAY_SIZE(Path));
			for (i = 0; i < AsciiStrLen(HashList.Entry[Index].Path); i++) {
				c = HashList.Entry[Index].Path[i];
				if (c < ' ' || c > 0x80)
					c = '?';
				Path[i] = (CHAR16)c;
			}
			Path[i] = L'\0';
		} else {
			// Hash the file and compare the result to the expected value
			// TODO: We should also handle progress & cancellation in HashFile()
			Status = HashFile(Root, Path, ComputedHash);
			if (Status == EFI_SUCCESS &&
				(CompareMem(ComputedHash, ExpectedHash, MD5_HASHSIZE) != 0))
				Status = EFI_CRC_ERROR;
		}

		// Report failures
		if (EFI_ERROR(Status)) {
			PrintFailedEntry(Status, Path, NumFailed++);
			UnicodeSPrint(NumFailedString, ARRAY_SIZE(NumFailedString),
				L" [%d failed]", NumFailed);
		}
	}

	// Final progress report
	SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 2);
	Print(L"%d/%d file%s processed%s\n", Index,
		HashList.Size, PluralFiles, NumFailedString);

out:
	SafeFree(HashList.Buffer);
	SafeFree(EmptyLine);
	ExitCheck(NumFailed);

	return Status;
}
