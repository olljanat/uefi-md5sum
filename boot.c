/*
 * uefi-md5sum: UEFI MD5Sum validator
 * Copyright © 2023 Pete Batard <pete@akeo.ie>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "boot.h"

/* The following header is generated by the build process on prod */
#include "version.h"

/*
 * When performing tests with GitHub Actions, we want to remove all
 * colour formatting as well force shutdown on exit (to exit qemu)
 * so we need a variable to tell us if we are running in test mode.
 */
BOOLEAN IsTestMode = FALSE;

/* Strings used to identify the plaform */
#if defined(_M_X64) || defined(__x86_64__)
  STATIC CHAR16* Arch = L"x64";
#elif defined(_M_IX86) || defined(__i386__)
  STATIC CHAR16* Arch = L"ia32";
#elif defined (_M_ARM64) || defined(__aarch64__)
  STATIC CHAR16* Arch = L"aa64";
#elif defined (_M_ARM) || defined(__arm__)
  STATIC CHAR16* Arch = L"arm";
#elif defined(_M_RISCV64) || (defined (__riscv) && (__riscv_xlen == 64))
  STATIC CHAR16* Arch = L"riscv64";
#else
#  error Unsupported architecture
#endif

/**
  Display a centered application banner
 **/
STATIC VOID DisplayBanner(VOID)
{
	UINTN i, Len;
	CHAR16 String[BANNER_LINE_SIZE + 1];

	// The platform logo may still be displayed → remove it
	gST->ConOut->ClearScreen(gST->ConOut);

	SetText(TEXT_REVERSED);
	Print(L"\n%c", BOXDRAW_DOWN_RIGHT);
	for (i = 0; i < BANNER_LINE_SIZE - 2; i++)
		Print(L"%c", BOXDRAW_HORIZONTAL);
	Print(L"%c\n", BOXDRAW_DOWN_LEFT);

	UnicodeSPrint(String, ARRAY_SIZE(String), L"UEFI md5sum %s (%s)", VERSION_STRING, Arch);
	Len = SafeStrLen(String);
	V_ASSERT(Len < BANNER_LINE_SIZE);
	Print(L"%c", BOXDRAW_VERTICAL);
	for (i = 1; i < (BANNER_LINE_SIZE - Len) / 2; i++)
		Print(L" ");
	Print(String);
	for (i += Len; i < BANNER_LINE_SIZE - 1; i++)
		Print(L" ");
	Print(L"%c\n", BOXDRAW_VERTICAL);

	UnicodeSPrint(String, ARRAY_SIZE(String), L"<https://md5.akeo.ie>");
	Len = SafeStrLen(String);
	V_ASSERT(Len < BANNER_LINE_SIZE);
	Print(L"%c", BOXDRAW_VERTICAL);
	for (i = 1; i < (BANNER_LINE_SIZE - Len) / 2; i++)
		Print(L" ");
	Print(String);
	for (i += Len; i < BANNER_LINE_SIZE - 1; i++)
		Print(L" ");
	Print(L"%c\n", BOXDRAW_VERTICAL);

	Print(L"%c", BOXDRAW_UP_RIGHT);
	for (i = 0; i < 77; i++)
		Print(L"%c", BOXDRAW_HORIZONTAL);
	Print(L"%c\n\n", BOXDRAW_UP_LEFT);
	DefText();
}

/*
 * Application entry-point
 * NB: This must be set to 'efi_main' for gnu-efi crt0 compatibility
 */
EFI_STATUS EFIAPI efi_main(EFI_HANDLE BaseImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
	EFI_STATUS Status;
	EFI_LOADED_IMAGE_PROTOCOL* LoadedImage;
	EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* Volume;
	EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *SimpleTextOut;
	EFI_FILE_HANDLE Root;
	HASH_LIST HashList = { 0 };
	CHAR16 *PluralFiles;
#if defined(EFI_DEBUG)
	UINTN Index;
#endif

#if defined(_GNU_EFI)
	InitializeLib(BaseImageHandle, SystemTable);
#endif

	IsTestMode = IsTestSystem();

	if (!IsTestMode)
		DisplayBanner();

	Status = gBS->LocateProtocol(&gEfiSimpleTextOutProtocolGuid, NULL, (VOID**)&SimpleTextOut);
	if (EFI_ERROR(Status)) {
		PrintError(L"Unable to initialize text output");
		goto out;
	}

	Status = gBS->OpenProtocol(BaseImageHandle, &gEfiLoadedImageProtocolGuid,
		(VOID**)&LoadedImage, BaseImageHandle, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);
	if (EFI_ERROR(Status)) {
		PrintError(L"Unable to access boot image interface");
		goto out;
	}

	// Open the the root directory on the boot volume
	Status = gBS->OpenProtocol(LoadedImage->DeviceHandle, &gEfiSimpleFileSystemProtocolGuid,
		(VOID**)&Volume, BaseImageHandle, NULL, EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);
	if (EFI_ERROR(Status)) {
		PrintError(L"Unable to open boot volume");
		goto out;
	}
	Root = NULL;
	Status = Volume->OpenVolume(Volume, &Root);
	if (EFI_ERROR(Status)) {
		PrintError(L"Unable to open root directory");
		goto out;
	}

	// Parse the md5sum.txt to construct a hash list
	Status = Parse(Root, HASH_FILE, &HashList);
	if (EFI_ERROR(Status))
		goto out;

	if (IsTestMode) {
		// Print any extra data we want to validate in test mode
		Print(L"[TEST] TotalBytes = 0x%lX\n", HashList.TotalBytes);
	} else {
		// Position our output near the center of the screen
		SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y);
		Print(L"Media verification - Press any key to cancel\n");
	}

	PluralFiles = (HashList.Size == 1) ? L"" : L"s";
	SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 1);
	Print(L"0/%d file%s processed\n", HashList.Size, PluralFiles);

out:
	// If running in test mode, close QEMU by invoking ShutDown()
	if (IsTestMode)
		ShutDown();

#if defined(EFI_DEBUG)
	// If running debug, wait for a user keystroke and shut down
	SetText(TEXT_YELLOW);
	Print(L"\nPress any key to exit.\n");
	DefText();
	gST->ConIn->Reset(gST->ConIn, FALSE);
	gST->BootServices->WaitForEvent(1, &gST->ConIn->WaitForKey, &Index);
	ShutDown();
#endif

	return Status;
}
