/*
 * uefi-md5sum: UEFI MD5Sum validator
 * Copyright © 2023 Pete Batard <pete@akeo.ie>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "boot.h"

/* The following header is generated by the build process on prod */
#include "version.h"

/*
 * When performing tests with GitHub Actions, we want to remove all
 * colour formatting as well force shutdown on exit (to exit qemu)
 * so we need a variable to tell us if we are running in test mode.
 */
BOOLEAN IsTestMode = FALSE;

/* Strings used to identify the plaform */
#if defined(_M_X64) || defined(__x86_64__)
  STATIC CHAR16* Arch = L"x64";
#elif defined(_M_IX86) || defined(__i386__)
  STATIC CHAR16* Arch = L"ia32";
#elif defined (_M_ARM64) || defined(__aarch64__)
  STATIC CHAR16* Arch = L"aa64";
#elif defined (_M_ARM) || defined(__arm__)
  STATIC CHAR16* Arch = L"arm";
#elif defined(_M_RISCV64) || (defined (__riscv) && (__riscv_xlen == 64))
  STATIC CHAR16* Arch = L"riscv64";
#else
#  error Unsupported architecture
#endif

/**
  Display a centered application banner
 **/
STATIC VOID DisplayBanner(UINTN Cols)
{
	UINTN i, Len;
	CHAR16* Line;

	// The platform logo may still be displayed → remove it
	gST->ConOut->ClearScreen(gST->ConOut);

	V_ASSERT(Cols > 79);
	Line = AllocatePool((Cols + 1) * sizeof(CHAR16));
	if (Line == NULL)
		return;

	Cols -= 1;
	SetTextPosition(0, 0);
	SetText(TEXT_REVERSED);
	Print(L"%c", BOXDRAW_DOWN_RIGHT);
	for (i = 0; i < Cols - 2; i++)
		Print(L"%c", BOXDRAW_HORIZONTAL);
	Print(L"%c", BOXDRAW_DOWN_LEFT);

	SetTextPosition(0, 1);
	UnicodeSPrint(Line, Cols, L"UEFI md5sum %s (%s)", VERSION_STRING, Arch);
	Len = SafeStrLen(Line);
	V_ASSERT(Len < Cols);
	Print(L"%c", BOXDRAW_VERTICAL);
	for (i = 1; i < (Cols - Len) / 2; i++)
		Print(L" ");
	Print(Line);
	for (i += Len; i < Cols - 1; i++)
		Print(L" ");
	Print(L"%c", BOXDRAW_VERTICAL);

	SetTextPosition(0, 2);
	UnicodeSPrint(Line, Cols, L"<https://md5.akeo.ie>");
	Len = SafeStrLen(Line);
	V_ASSERT(Len < Cols);
	Print(L"%c", BOXDRAW_VERTICAL);
	for (i = 1; i < (Cols - Len) / 2; i++)
		Print(L" ");
	Print(Line);
	for (i += Len; i < Cols - 1; i++)
		Print(L" ");
	Print(L"%c", BOXDRAW_VERTICAL);

	SetTextPosition(0, 3);
	Print(L"%c", BOXDRAW_UP_RIGHT);
	for (i = 0; i < Cols - 2; i++)
		Print(L"%c", BOXDRAW_HORIZONTAL);
	Print(L"%c", BOXDRAW_UP_LEFT);
	DefText();

	FreePool(Line);
}

/*
 * Application entry-point
 * NB: This must be set to 'efi_main' for gnu-efi crt0 compatibility
 */
EFI_STATUS EFIAPI efi_main(EFI_HANDLE BaseImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
	EFI_STATUS Status;
	EFI_LOADED_IMAGE_PROTOCOL* LoadedImage;
	EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* Volume;
	EFI_FILE_HANDLE Root;
	EFI_INPUT_KEY Key;
	HASH_LIST HashList = { 0 };
	CHAR8 c;
	CHAR16 Path[PATH_MAX + 1], NumFailedString[32] = { 0 }, *PluralFiles;
	CHAR16 *EmptyLine = NULL;
	UINT8 ComputedHash[MD5_HASHSIZE], ExpectedHash[MD5_HASHSIZE];
	UINTN i, Index, Cols, Rows, NumFailed = 0;

#if defined(_GNU_EFI)
	InitializeLib(BaseImageHandle, SystemTable);
#endif

	// Determine if we are running in test mode.
	// Note that test mode is no less secure than regular mode.
	// It only produces or removes some specific output from the screen.
	IsTestMode = IsTestSystem();

	// Find the amount of console real-estate we have at out disposal
	Status = gST->ConOut->QueryMode(gST->ConOut, gST->ConOut->Mode->Mode, &Cols, &Rows);
	if (EFI_ERROR(Status)) {
		// Couldn't get the console dimensions
		Cols = 80;
		Rows = 40;
	}

	// Display the top banner
	if (!IsTestMode)
		DisplayBanner(Cols);

	// Create blank line which we'll use to erase when overwriting a line
	EmptyLine = AllocateZeroPool((Cols + 1) * sizeof(CHAR16));
	if (EmptyLine != NULL) {
		for (i = 0; i < Cols; i++)
			EmptyLine[i] = L' ';
	}

	// Access the loaded image so we can open the current volume
	Status = gBS->OpenProtocol(BaseImageHandle, &gEfiLoadedImageProtocolGuid,
		(VOID**)&LoadedImage, BaseImageHandle, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);
	if (EFI_ERROR(Status)) {
		PrintError(L"Unable to access boot image interface");
		goto out;
	}

	// Open the the root directory on the boot volume
	Status = gBS->OpenProtocol(LoadedImage->DeviceHandle, &gEfiSimpleFileSystemProtocolGuid,
		(VOID**)&Volume, BaseImageHandle, NULL, EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);
	if (EFI_ERROR(Status)) {
		PrintError(L"Unable to open boot volume");
		goto out;
	}
	Root = NULL;
	Status = Volume->OpenVolume(Volume, &Root);
	if (EFI_ERROR(Status)) {
		PrintError(L"Unable to open root directory");
		goto out;
	}

	// Parse md5sum.txt to construct a hash list
	Status = Parse(Root, HASH_FILE, &HashList);
	if (EFI_ERROR(Status))
		goto out;

	if (IsTestMode) {
		// Print any extra data we want to validate
		Print(L"[TEST] TotalBytes = 0x%lX\n", HashList.TotalBytes);
	} else {
		// Position our output near the center of the screen
		SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y);
		Print(L"Media verification - Press any key to cancel\n");
	}

	// Now go through each entry we parsed
	PluralFiles = (HashList.Size == 1) ? L"" : L"s";
	gST->ConIn->Reset(gST->ConIn, FALSE);
	for (Index = 0; Index < HashList.Size; Index++) {
		// Check for user cancellation
		if (gST->ConIn->ReadKeyStroke(gST->ConIn, &Key) != EFI_NOT_READY)
			break;

		// Report progress
		if (!IsTestMode) {
			SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 2);
			Print(L"%d/%d file%s processed%s\n", Index,
				HashList.Size, PluralFiles, NumFailedString);
		}

		// Convert the expected hexascii hash to a binary value we can use
		ZeroMem(ExpectedHash, sizeof(ExpectedHash));
		for (i = 0; i < MD5_HASHSIZE * 2; i++) {
			c = HashList.Entry[Index].Hash[i];
			V_ASSERT(IsValidHexAscii(c));
			ExpectedHash[i / 2] <<= 4;
			ExpectedHash[i / 2] |= c >= 'a' ? (c - 'a' + 0x0A) : c - '0';
		}

		// Convert UTF-8 sequences to UCS-2
		Status = Utf8ToUcs2(HashList.Entry[Index].Path, Path, ARRAY_SIZE(Path));
		if (EFI_ERROR(Status)) {
			// Truncate the path in case it's very long
			if (AsciiStrLen(HashList.Entry[Index].Path) > 80)
				HashList.Entry[Index].Path[80] = '\0';
			SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 4 + (NumFailed % FAILED_FILES_MAX));
			if (EmptyLine != NULL && !IsTestMode)
				Print(EmptyLine);
			SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 4 + (NumFailed % FAILED_FILES_MAX));
			PrintError(L"File '%a'", HashList.Entry[Index].Path);
			NumFailed++;
			UnicodeSPrint(NumFailedString, ARRAY_SIZE(NumFailedString),
				L" [%d failed]", NumFailed);
			continue;
		}

		// Hash the file and compare its value to the expected one
		// TODO: We will need to handle progress & cancellation in HashFile()
		Status = HashFile(Root, Path, ComputedHash);
		if (Status == EFI_SUCCESS &&
			(CompareMem(ComputedHash, ExpectedHash, MD5_HASHSIZE) != 0))
			Status = EFI_CRC_ERROR;
		if (EFI_ERROR(Status)) {
			// Truncate the path in case it's very long
			// TODO: Ideally we'd want long path reduction like Windows does
			if (SafeStrLen(Path) > 80)
				Path[80] = L'\0';
			SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 4 + (NumFailed % FAILED_FILES_MAX));
			if (EmptyLine != NULL && !IsTestMode)
				Print(EmptyLine);
			SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 4 + (NumFailed % FAILED_FILES_MAX));
			PrintError(L"File '%s'", Path);
			NumFailed++;
			UnicodeSPrint(NumFailedString, ARRAY_SIZE(NumFailedString),
				L" [%d failed]", NumFailed);
		}
	}

	SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 2);
	Print(L"%d/%d file%s processed%s\n", Index,
		HashList.Size, PluralFiles, NumFailedString);

out:
	SafeFree(HashList.Buffer);
	SafeFree(EmptyLine);
	// If running in test mode, shut down QEMU
	if (IsTestMode)
		ShutDown();

#if defined(EFI_DEBUG)
	// If running debug, wait for a user keystroke and shut down
	SetTextPosition(TEXT_POSITION_X, TEXT_POSITION_Y + 5 + MIN(NumFailed, FAILED_FILES_MAX));
	SetText(TEXT_YELLOW);
	Print(L"Press any key to exit.\n");
	DefText();
	gST->ConIn->Reset(gST->ConIn, FALSE);
	gST->BootServices->WaitForEvent(1, &gST->ConIn->WaitForKey, &Index);
	ShutDown();
#endif

	return Status;
}
